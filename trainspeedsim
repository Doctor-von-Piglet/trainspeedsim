#! /usr/bin/python3

class MultiDict:
    def __init__(self, d={}):
        self._layer1 = {}
        self._layer2 = {}
        # Expects input in the form {(k1a, k1b): v1, (k2a): v2} (a dictionary
        # of tuples-to-values)
        # For that matter a dict of lists-to-values works too
        # The basic idea is that it maps all members of a given key to the 
        # first element of that key, which is used as the key to the second
        # mapping which actually contains the values.
        # The fundamental operations on this object will be these:
        #  1. multidict[k] = v
        #     Sets key group containing k to value v.
        #     If key belongs to no key group, create a new key group containing
        #     only k and set its value to v.
        #  2. multidict.join(k1, k2) joins k1 to the key group containing k2.
        #     That is all it does; even if k1 originally belongs to (k1, k3),
        #     k3 is unaffected besides k1 being removed from its group.
        # Construction of this object will be considered like so:
        #  1. A key tuple-or-list of the form (k1a, k1b, ...): v1 will be 
        #     treated as:
        #     if a key group already contains k1a:
        #       multidict[k1a] = v1
        #     else if no key group already contains k1a:
        #       multidict[k1a] = v1
        #     Oh I guess multidict[k] takes care of this already.
        #     Anyway the rest would be:
        #     multidict.join(k1b, k1a)
        #     multidict.join(..., k1a or k1b or any other key in that key group 
        #       it doesn't matter)
        # For example: {(k1a, k1b): v1, (k1b): v2} would create self._layer1 
        # and _layer2 as follows:
        #  1. Key is (k1a, k1b). Value is v1.
        #     This should create a new key group containing k1a and then join
        #     k1b to it.
        #     md[k1a] = v1:
        #     self._layer1 = {k1a: k1a}
        #     self._layer2 = {k1a: v1}
        #     md.join(k1b, k1a):
        #     self._layer1 = {k1a: k1a, k1b: k1a}
        #  2. Key is (k1b). Value is v2.
        #     This should set key group containing k1b to the value v2.
        #     md[k1b] = v2:
        #     self._layer1 = {k1a: k1a, k1b: k1a} (no change)
        #     self._layer2 = {k1a: v2}
        for k in d:
            for i in range(len(k)):
                subkey = k[i]
                if i==0:
                    # become the "root node" of this key-set
                    rootkey = subkey
                    self.__setitem__(subkey, d[k])
                else:
                    self.join(subkey, rootkey)

    def __repr__(self):
        # TODO iterator for MultiDict
        # YIKES I have to build these darn things in reverse
        # I mean seriously if the number of keys is N and the number of values/
        # groups is M this is going to take O(N*M) time.
        diclist = {}
        for rootkey in self._layer2:
            val = self._layer2[rootkey]
            for key in self._layer1:
                if self._layer1[key] == rootkey:
                    if val in diclist:
                        diclist[val].append(key)
                    else:
                        diclist[val] = [key]

        out = "{"
        for val in diclist:
            out = out + str(tuple(diclist[val]))
            out = out + ": " + repr(val) + ", "
        out = out + "}"

        return out

    def __setitem__(self, key, value):
        if key in self._layer1:
            self._layer2[self._layer1[key]] = value
        else:
            self._layer1[key] = key
            self._layer2[self._layer1[key]] = value
                
    def __getitem__(self, key):
        if key in self._layer1:
            return self._layer2[self._layer1[key]]
        else:
            raise KeyError()

    def __contains__(self, key):
        return key in self._layer1

    #def
    # TODO do __delitem__ and __keys__ and stuff later

    def join(self, key_wanting_to_join, key_dest):
        self._layer1[key_wanting_to_join] = self._layer1[key_dest]
        # TODO do something if a key group no longer has members
            
class HasUnit: # virtual/interface-ish
    # Subclasses will define the values, units, and their conversions

    def __init__(self, val, unit):
        pass

    def __str__(self):
        return str(self._val)+" "+self._unit

    def val(self):
        return self._val
    
    def unit(self):
        return self._unit

    def to_bigger_unit(self):
        assert self._unit in self._bigger # keys are the small units
        return type(self)(self._val * self._conv[(self._unit, \
            self._bigger[self._unit])], self._bigger[self._unit])

    def to_smaller_unit(self):
        assert self._unit in self._smaller # keys are the big units
        k = (self._unit, self._smaller[self._unit])
        smaller_unit_val = self._val * self._conv[k]
        return type(self)(smaller_unit_val, self._smaller[self._unit])
    
    # comparison methods compatible with both HasUnits and numbers

    def _compare_to(self, other):
        if isinstance(other, HasUnit):
            assert self._unit == other._unit
            to_compare = other._val
        elif isinstance(other, (int, float)):
            to_compare = other
        else:
            raise TypeError("incomparable types")

        return to_compare

    def __eq__(self, other):
        return self._val == self._compare_to(other)

    def __lt__(self, other):
        return self._val < self._compare_to(other)

    def __le__(self, other):
        to_compare = self._compare_to(other)
        return self < to_compare or self == to_compare

    def __gt__(self, other):
        return not self <= other

    def __ge__(self, other):
        return not self < other
        
    # maths
    def __add__(self, other):
        to_math = self._compare_to(other)
        return Pos(self._val + to_math, self._unit)

    def __sub__(self, other):
        to_math = self._compare_to(other)
        return Pos(self._val - to_math, self._unit)

    def __mod__(self, other):
        to_math = self._compare_to(other)
        return Pos(self._val % to_math, self._unit)

class Pos(HasUnit):
    # conversions
    _conv = {               \
        ("f","mi"): 1/5280, \
        ("mi","f"): 5280,   \
        ("m","km"): 1/1000, \
        ("km","m"): 1000    \
    }
    _bigger = {     \
        "f": "mi",  \
        "m": "km"   \
    }
    _smaller = {    \
        "mi": "f",  \
        "km": "m",  \
    }

    def __init__(self, val, unit):
        assert unit in ["f","mi","m","km"]
        self._val = val
        self._unit = unit

class Speed(HasUnit):
    _conv = {                       \
        ("f/s","mi/h"): 3600/5280,  \
        ("mi/h","f/s"): 5280/3600,  \
        ("m/s","km/h"): 3600/1000,  \
        ("km/h","m/s"): 1000/3600   \
    }

    _bigger = {         \
        "f/s": "mi/h",  \
        "m/s": "km/h"   \
    }

    _smaller = {        \
        "mi/h": "f/s",  \
        "km/h": "m/s"   \
    }

    def __init__(self, val, unit):
        assert unit in ["f/s","mi/h","m/s","km/h"]
        self._val = val
        self._unit = unit
    
class TrackSeg:
    def __init__(self, index, start, end, speed):
        assert index >= 0 and type(index) is int
        assert start <= end
        assert speed >= 0
        self._index = index
        self._start = start
        self._end   = end
        self._speed = speed
    
    def __str__(self):
        # want units to be in miles/km ("big" units)
        # if self._start TODO
        return "id: {}, {} - {} @ {}".format(self._index, self._start.to_bigger_unit(), self._end.to_bigger_unit(), self._speed)
    #.to_bigger_unit())
    
    def __repr__(self):
        # TODO update this for HasUnits
        return "TrackSeg(index={}, start={}, end={}, speed={})".format(self._index, self._start, self._end, self._speed)
    
    def get_index(self):
        return self._index
    
    def get_start(self):
        return self._start
    
    def get_end(self):
        return self._end
    
    def get_speed(self):
        return self._speed
    
    def length(self):
        return self._end - self._start
    
class Track:
    from collections import namedtuple
    RawMaxSpeed = namedtuple("MaxSpeed", ["milepost", "speed"])

    def __init__(self, filename, units):
        # load the file into TrackSegs into
        self._track = self._load_maxspeeds(filename, units)
        # and throw if anything goes wrong
        assert len(self._track) > 0, "there must be at least one track segment"

    def __str__(self):
        out = "[\n"
        for seg in self._track:
            out += str(seg) + "\n"
        out += "]"
        return out

    def get_first_seg(self):
        return self._track[0]

    # throws IndexError and AssertionError
    def get_next_seg(self, index, direction):
        assert direction == "+" or direction == "-"
        if direction == "+": d = 1
        elif direction == "-": d = -1
        
        if index + d < 0: raise IndexError("Next segment index out of bounds")

        return self._track[index + d]

    def _load_maxspeeds(self, filename, units):
        assert units in ["imperial", "metric"]
        import csv
        raw_maxspeeds = [maxspeed for maxspeed in map (self.RawMaxSpeed._make, csv.reader(open(filename, "r"), delimiter='	', quoting=csv.QUOTE_NONNUMERIC))]
        
        if units == "imperial":
            pos_unit = "mi"
            speed_unit = "mi/h"
        elif units == "metric":
            pos_unit = "km"
            speed_unit = "km/h"
        else:
            assert False # should never get here

        # assign units
        # assumes units in file are "big units" (mi or km, mph or kph)
        # might change that later (TODO)
        # generate segments from that
        maxspeedsegs = []
        for x in range(0, len(raw_maxspeeds)-1):
            maxguy = raw_maxspeeds[x]
            mp1 = Pos(maxguy.milepost, pos_unit).to_smaller_unit()
            maxguy2 = raw_maxspeeds[x+1]
            mp2 = Pos(maxguy2.milepost, pos_unit).to_smaller_unit()
            #if maxguy2.speed != 0:
            speed1 = Speed(maxguy.speed, speed_unit).to_smaller_unit()
            seg = TrackSeg(x, mp1, mp2, speed1)
            if (x+1 == len(raw_maxspeeds)-1):
                speed2 = Speed(maxguy2.speed, speed_unit).to_smaller_unit()
                seg = TrackSeg(x, mp1, mp2, speed2)
            maxspeedsegs.append(seg)
            print("seg", x, seg)

        return maxspeedsegs
 
class Train:
    def __init__(self, track, acceleration, resolution):
        assert acceleration > 0
        assert resolution > 0 and type(resolution) is int
        self._track = track
        self._acceleration = acceleration
        self._resolution = resolution
        # then the derived attributes and defaults
        self._seg = self._track.get_first_seg()
        self._speed = self._seg.get_speed() # first segment better be 0 speed
        assert self._speed == 0 # oh I can make sure of that
        self._pos = self._seg.get_start()
        self._dir = "+"
        self._finished_seg = False

    # TODO speed as Speed
    def __str__(self):
        return ("pos: {:.1f} mi, speed {:.2f} mph, dir: {}, seg: ({}), accel: {}, "+ \
            "res: {}, finished {}, track defined: {}").format(self._pos/5280, self._speed*3600/5280, self._dir, self._seg, self._acceleration, self._resolution, self._finished_seg, self._track is not None)

    def get_pos(self):
        return self._pos

    def get_speed(self):
        return self._speed

    def finished_seg(self):
        return self._finished_seg

    def at_end_of_track(self):
        assert self._dir == "+" or self._dir == "-"
        if self._dir == "+":
            try:
                self._track.get_next_seg(self._seg.get_index(), self._dir)
            except IndexError:
                # we must be at last segment already
                # check if we are at the end of it
                return self._pos == self._seg.get_end()
        else:
            return self._seg == self._track.get_first_seg() and self._pos == \
                self._seg.get_start()

    def set_dir(self, direction):
        assert direction == "+" or direction == "-"
        self._dir = direction
        self._finished_seg = False

    # kind of does everything
    # travels along 1 resolution of track each call
    # automatically loads the next TrackSeg when at end of current one
    # returns false when it's finished the last resolution-length in seg
    # (i.e. self._finished_seg == True I think)
    # (except when it's at end of last seg in track, in which case it returns
    # False even though self._finished_seg is True)
    # ...
    # I need to think this through better.
    def travel_seg(self):
        if self._finished_seg == True:
            # load next seg
            try:
                self._seg = self._track.get_next_seg(\
                    self._seg.get_index(), self._dir)
                self._finished_seg = False
            except IndexError:
                # must be at one end of the track
                return False
            #return True # not sure what this one was here for
    
        if self._finished_seg == False:
            if (self._seg.length() != 0):
                self._finished_seg = self._travel_non0_seg()
            else:
                self._speed = min(self._seg.get_speed(), self._speed)
                # well I guess we're instantly finished with a 0-length seg
                self._finished_seg = True
            print("seg speed: ",self._seg.get_speed(), \
                "\nself speed:", self._speed, ";")

        return self._finished_seg

    # takes all units in feet units
    def _accelerate(self, v_target, acc, v_i, d):
        assert v_target >= 0 and v_i >= 0
        assert d >= 0
        assert acc > 0
        nacc = acc
        from math import sqrt
        t = ( -v_i + sqrt(v_i**2 - 4.0 * 0.5 * nacc * -d) ) / (2.0*0.5*nacc)
        v_f = nacc * t + v_i
        return v_f

    def _travel_non0_seg(self):
        assert self._seg.length() % self._resolution == 0

        # accelerate() over one resolution of distance? I didn't think 
        # this far ahead.
        segspeed = self._seg.get_speed()
        acc_speed = Speed(self._accelerate(segspeed.val(), self._acceleration, \
            self._speed.val(), self._resolution), self._speed.unit())
        self._speed = min(segspeed, acc_speed)
            

        # always travels over seg at least *once*, even if zero-length
        assert self._dir == "+" or self._dir == "-"
        if self._dir == "+":
            self._pos += self._resolution
            if self._pos == self._seg.get_end():
                self._finished_seg = True
        elif self._dir == "-":
            self._pos -= self._resolution
            if self._pos == self._seg.get_start():
                self._finished_seg = True
        return self._finished_seg

class ArgvError(Exception):
    """ An error having to do with the command-line arguments """
    pass

class Config:
    class FlagDesc:
        def __init__(self, val, needs_val=True):
            self.val = val
            self.needs_val = needs_val

    def __init__(self, argv):
        self._flagsdict = MultiDict({("-u", "--units"): self.FlagDesc(None)})
        self._flagsdict["-b"] = self.FlagDesc(None, False)
        self._flagsdict.join("--boolean", "-b")
        self._flagsdict["-h"] = self.FlagDesc(None, False)
        self._flagsdict.join("--help", "-h")
        
        # declare what we're configuring (just to be clear)
        self.mode = None
        self.infile = None
        self.units = None

        self._parse(argv)
        self._validate_args()
    
    def _parse(self, argv):
        # input filename is just by itself, all other args are -<FLAG> val
        assert len(argv) > 1
        #for arg in argv[1:]:
        isflagval = False
        for arg in argv[1:]:
            if arg[0] == "-" and not isflagval: # it's a flag
                if arg in self._flagsdict:
                    if self._flagsdict[arg].needs_val:
                        flag = arg
                        isflagval = True # next argv entry must be a value
                    else:
                        self._flagsdict[arg].val = True
                else:
                    raise KeyError("No such flag")
            elif isflagval:
                if self._flagsdict[flag].val == None:
                    self._flagsdict[flag].val = arg
                    isflagval = False
                else:
                    raise ArgvError("Cannot define flag multiple times")
            else: # must be by itself (so probably input filename)
                if self.infile == None:
                    self.infile = arg
                else:
                    raise ArgvError("Cannot have multiple input files")
        
    def _validate_args(self):
        # make sure arguments are logical and consistent etc.
        if self._flagsdict["-h"].val == True:
            self.mode = "help"
        else:
            # default configuration or something
            self.mode = "sim"

        if self.mode == "sim":
            if self._flagsdict["-u"].val in [None, "imperial"]:
                self.units = "imperial"
            if self.infile == None:
                raise ArgvError("Must specify input file")

        if self.mode == "help":
            pass
       
    def gen_help(self):
        # generate this automagically from self._flagsdict later
        return  "trainspeedsim [-h|--help | [-u|--units UNIT] INPUT_FILE\n" + \
                "  -u|--units: imperial|metric"

class Simulation:
    from collections import namedtuple
    PosSpeed = namedtuple("PosSpeed", ["pos", "speed"])

    def __init__(self, filename, accel, resolution, units):
        assert accel > 0
        assert resolution > 0 and type(resolution) is int
        assert units in ["imperial", "metric"] # there must be a more generic way
        self._units = units
        self._resolution = resolution
        self._track = Track(filename, self._units)
        self._train = Train(self._track, accel, self._resolution)
        self._best_speeds = []

    def run(self):

        fwd_best_speeds = self._gen_best_speeds_dir("+")
        
        rev_best_speeds = self._gen_best_speeds_dir("-")

        # note: all of that up there generated duplicate PosSpeeds for 0-length 
        # segments
        # we will need to fix this when building self._best_speeds

        lastps = None
        for paired in zip(fwd_best_speeds, reversed(rev_best_speeds)):
            assert paired[0].pos == paired[1].pos
            ps = self.PosSpeed(paired[0].pos, min(paired[0].speed, \
                paired[1].speed))
            if (lastps is None or (ps.pos != lastps.pos or ps.speed != lastps.speed)):
                self._best_speeds.append(ps)
            lastps = ps
            
    def output(self):
        for point in self._best_speeds:
            # round so that e.g. 49.99999999999999 displays as 50.0
            # using HasUnit introduces rounding error, so that's compensating
            # sort of
            print("{:.1f}, {}".format(point.pos.to_bigger_unit().val(), \
                round(point.speed.to_bigger_unit().val(), 10)))
    
    def _gen_best_speeds_dir(self, direction):
        assert direction=="+" or direction=="-"
        best = []
        self._train.set_dir(direction)
        while not self._train.at_end_of_track():
            self._train.travel_seg()
            if not self._train.at_end_of_track(): # prevents repeating last seg
                best.append(self.PosSpeed(self._train.get_pos(), \
                    self._train.get_speed()))
        return best
        

if __name__ == "__main__":

    import sys
    conf = Config(sys.argv)

    if conf.mode == "sim":
        try:
            sim = Simulation(conf.infile, 1.25, 528, conf.units)
        except FileNotFoundError as e:
            sys.stderr.write(str(e)+"\n")
            exit()
        sim.run()
        sim.output()
    elif conf.mode == "help":
        print(conf.gen_help())

